---
category: Java
curated_by: Claude Sonnet 4.5
difficulty: medium
generated: 2026-02-09
interview_frequency: medium
prerequisites: []
related: []
sources: 1
subtopic: Reflection & Annotation
tags: []
---

# Reflection & Annotation (리플렉션과 어노테이션)

## 📝 Reflection이란?

**구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 Java API**

---

## 🪞 Reflection 개념

### 실체와 거울

```
실체 = Class
거울 = JVM 메모리 영역
```

**JVM은 클래스 정보를 클래스 로더를 통해 읽어와서 JVM 메모리에 저장**

**힙 영역에 로드된 Class 타입 객체를 통해 인스턴스 생성 지원**

---

## 🔍 Class 클래스

**`java.lang` 패키지에서 제공**

**실행 중인 Java 애플리케이션의 클래스와 인터페이스 정보를 가진 클래스**

**특징:**
- Public 생성자 없음
- Class 객체는 JVM에 의해 자동 생성

---

### Class 기능

1. 클래스에 붙은 어노테이션 조회
2. 클래스 생성자 조회
3. 클래스 필드 조회
4. 클래스 메서드 조회
5. 부모 클래스, 인터페이스 조회

---

### Class 객체 가져오기

#### 1. {클래스타입}.class

```java
Class&lt;?&gt; clazz = Cat.class;
```

---

#### 2. {인스턴스}.getClass()

```java
Cat daengi = new Cat("daengi");
Class&lt;?&gt; clazz = daengi.getClass();
```

---

#### 3. Class.forName("{전체 도메인 이름}")

```java
Class&lt;?&gt; clazz = Class.forName("org.example.Cat");
```

---

## 🔧 Reflection 메서드

### getMethods vs getDeclaredMethods

#### getMethods

**상속한 메서드 포함 + public 메서드만**

---

#### getDeclaredMethods

**접근 제어자 무관 + 직접 선언한 메서드만**

---

## 💻 Reflection 사용 예시

### Private 생성자 접근

```java
// 1. 생성자 가져오기
Constructor&lt;?&gt; constructor = Cat.class.getDeclaredConstructor();

// 2. setAccessible(true) 설정
constructor.setAccessible(true);

// 3. 객체 생성
Cat cat = (Cat) constructor.newInstance();
```

---

### Private 필드 접근

```java
// 1. 필드 가져오기
Field nameField = Cat.class.getDeclaredField("name");

// 2. setAccessible(true) 설정
nameField.setAccessible(true);

// 3. 값 변경
nameField.set(cat, "meow");
```

---

### 메서드 호출

```java
// 1. 메서드 가져오기
Method meowMethod = Cat.class.getDeclaredMethod("meow");

// 2. setAccessible(true) 설정
meowMethod.setAccessible(true);

// 3. 메서드 호출
meowMethod.invoke(cat);
```

---

## 🎯 Reflection 사용처

### 프레임워크/라이브러리

1. **JPA**
2. **Jackson**
3. **Mockito**
4. **IntelliJ 자동완성 기능**

---

## 🏗️ 기본 생성자의 필요성

**JPA Entity, RequestDTO, ResponseDTO는 기본 생성자 필요**

### 이유

**기본 생성자로 객체 생성 후 필드에 값 넣는 것이 가장 간단**

---

### 문제점

#### 1. 어떤 생성자 사용할지 선택 어려움

```java
public Cat(String name) { ... }
public Cat(String name, int age) { ... }
public Cat(String name, int age, String color) { ... }
```

---

#### 2. 생성자에 로직 있으면 값 바로 넣기 어려움

```java
public Cat(String name) {
    this.name = name.toUpperCase(); // 로직 존재
}
```

---

#### 3. 파라미터 타입 같으면 필드 매칭 어려움

```java
public Cat(String name, String color) { ... }
// name과 color 구분 어려움
```

---

### 해결

**기본 생성자 사용 → 모든 경우의 수 고려 불필요**

```java
Cat cat = new Cat(); // 기본 생성자
nameField.set(cat, "meow"); // 필드에 값 설정
```

---

## 🏷️ Annotation 동작 원리

### 1. Reflection으로 정보 가져오기

**클래스, 메서드, 파라미터 정보 조회**

---

### 2. Annotation 확인

**getAnnotation(s), getDeclaredAnnotation(s) 사용**

---

### 3. 로직 수행

**Annotation 있으면 원하는 로직 실행**

---

## ✅ Reflection 장점

### 1. 유연성

**런타임 시점에서 클래스 인스턴스 생성**

**접근 제어자 무관하게 필드/메서드 접근**

---

## ❌ Reflection 단점

### 1. 성능 저하

**일반 메서드 호출보다 훨씬 느림**

**런타임 시점 분석 → JVM 최적화 불가**

---

### 2. 타입 체크 불가

**컴파일 시점 type check 불가**

```java
Class.forName("org.example.WrongClass"); // ClassNotFoundException
```

---

### 3. 코드 복잡성

**코드가 지저분하고 장황해짐**

---

### 4. 추상화 파괴

**접근 불가 필드/메서드 접근 가능**

**모든 클래스 정보 확인 가능**

---

## 💡 Reflection 사용 이유

### 1. 동적 객체 생성

**런타임 시 클래스 이름으로 객체 생성**

---

### 2. 클래스 정보 조사

**메서드, 필드, 상위 클래스, 인터페이스 조사**

---

### 3. 동적 메서드 호출

**메서드 이름과 매개변수를 동적으로 지정하여 호출**

---

### 4. Annotation 처리

**런타임 시 Annotation 분석 및 처리**

---

### 5. 리소스 접근

**클래스 로더로 리소스 동적 로드**

---

## ⚠️ 주의 사항

### 신중하게 사용

- 실행 시간 타입 검사 회피
- 성능 저하 발생
- 코드 복잡성 증가

---

### 사용 권장 범위

**프레임워크, 라이브러리, 개발자 도구 개발**

**일반 애플리케이션 개발에서는 최소화**

---

## ❓ 면접 질문 예시

### Q1. Reflection이란 무엇인가요?

**답변:**
Reflection은 구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 Java API입니다. JVM은 클래스 정보를 클래스 로더를 통해 읽어와서 JVM 메모리에 저장하고, 힙 영역에 로드된 Class 타입 객체를 통해 인스턴스를 생성할 수 있도록 지원합니다.

### Q2. Reflection은 어떤 경우에 사용되나요?

**답변:**
Reflection은 주로 프레임워크나 라이브러리에서 사용됩니다. JPA, Jackson, Mockito, IntelliJ 자동완성 기능 등에서 활용되며, 런타임 시점에 클래스 정보를 동적으로 조사하고 객체를 생성하거나 메서드를 호출할 때 사용됩니다.

### Q3. JPA Entity가 기본 생성자를 필요로 하는 이유는?

**답변:**
Reflection으로 객체를 생성할 때 기본 생성자로 객체를 생성하고 필드를 통해 값을 넣어주는 것이 가장 간단한 방법이기 때문입니다. 어떤 생성자를 사용할지 선택하기 어렵고, 생성자에 로직이 있거나 파라미터 타입이 같으면 값을 알맞게 넣어주기 힘들지만, 기본 생성자를 사용하면 이 모든 경우의 수를 고려하지 않아도 됩니다.

### Q4. Annotation은 어떻게 작동하나요?

**답변:**
1) Reflection을 통해 클래스, 메서드, 파라미터 정보를 가져옵니다.
2) getAnnotation(s), getDeclaredAnnotation(s) 메서드로 원하는 Annotation이 붙어있는지 확인합니다.
3) Annotation이 붙어 있다면 원하는 로직을 수행합니다.

### Q5. Reflection의 단점은?

**답변:**
1) 일반 메서드 호출보다 성능이 훨씬 떨어집니다. 런타임 시점에 클래스를 분석하기 때문에 JVM 최적화가 불가능합니다.
2) 컴파일 시점에 타입 체크 기능을 사용할 수 없습니다.
3) 코드가 지저분하고 장황해집니다.
4) 접근할 수 없는 필드와 메서드에 접근 가능하여 추상화를 파괴합니다.

---

## 📚 원본 참고 자료

### 출처: 2023-CS-Study
- 파일: `/Users/PARK/Desktop/MyBook/2023-CS-Study/java/java_reflection.md`
- 내용: Reflection, Class 클래스, Annotation, 기본 생성자

### 추가 학습 자료

- [슬기로운 개발생활](https://dev-coco.tistory.com/153)
- [10분 테코톡](https://www.youtube.com/watch?v=67YdHbPZJn4)
- [Oracle](https://www.oracle.com/technical-resources/articles/java/javareflection.html)